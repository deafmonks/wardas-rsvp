<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shaadi Invitation & RSVP</title>

  <!-- Google Font: Mukta -->
  <link href="https://fonts.googleapis.com/css2?family=Mukta:wght@300;500;700&display=swap" rel="stylesheet" /> <!-- [web:57] -->

  <link rel="stylesheet" href="style.css" />
  <style>
    /* Prevent horizontal page scrolling */
    html, body { overflow-x: hidden; }

    /* Animate only the right-most mini-carousel (fade effect) */
    .mini-carousel.right-carousel { overflow: hidden; }
    .mini-carousel.right-carousel .slides { position: relative; height: auto; }
    .mini-carousel.right-carousel .slide { position: absolute; inset: 0; opacity: 0; transition: opacity .7s ease; }
    .mini-carousel.right-carousel .slide.active { opacity: 1; z-index: 2; }
    .mini-carousel.right-carousel .slide img { width: 100%; height: 100% !important; object-fit: cover; display: block; }

    /* Core carousel sizing: prevent inner scrolling and ensure slides are image-only */
    .carousel-grid { overflow: hidden; max-width: 100vw; box-sizing: border-box; }
    /* Make carousels responsive: allow them to scale and remain visible on small screens */
    .mini-carousel { flex: 1 1 250px; width: 250px; max-width: 33%; min-width: 140px; box-sizing: border-box; }
    .mini-carousel .slides { overflow: hidden; }
    .mini-carousel .slide img { width: 100%; height: 100% !important; object-fit: cover; display: block; }

    /* Optional: ensure any specially-targeted image (hands) matches the cover sizing */
    img.hands-match { width: 100%; height: 100% !important; object-fit: cover; display: block; border-radius: 8px !important; transform: translateY(-20%); transition: transform .25s ease; }
     /* Middle carousel defaults (desktop) */
     .mini-carousel.middle-carousel .slide { display: block; }
     .mini-carousel.middle-carousel .slide + .slide { margin-top: 8px; }

     /* HERO MIDDLE: Stack IMG3 above hands and size them like the couple-photos
       These rules only target the hero area to avoid changing invite-area images */
     .hero .mini-carousel.middle-carousel { max-width: 280px; width: 100%; box-sizing: border-box; }
    .hero .mini-carousel.middle-carousel .slides { display: flex; flex-direction: column; overflow: visible !important; }
      .hero .mini-carousel.middle-carousel .slide { display: block !important; position: relative !important; overflow: hidden !important; border-radius: 8px !important; }
      /* Ensure both middle slides are always visible on desktop (ignore .active toggling) */
      .hero .mini-carousel.middle-carousel .slide:not(.active) { display: block !important; }
    .hero .mini-carousel.middle-carousel .slide img { width: 100% !important; height: auto !important; border-radius: 8px !important; object-fit: cover !important; display: block !important; }
      .hero .mini-carousel.middle-carousel .slide + .slide { margin-top: 8px !important; }

     /* HERO RIGHT: ensure right-carousel images are the same visual size as couple-photos
       Make the right carousel container match the middle's max-width so images line up */
    .hero .mini-carousel.right-carousel { max-width: 280px; width: 100%; box-sizing: border-box; }
    /* allow JS to control the slides container height so all right images render at equal size */
    .hero .mini-carousel.right-carousel .slides { position: static !important; }
    .hero .mini-carousel.right-carousel .slide { position: static !important; display: none !important; }
    .hero .mini-carousel.right-carousel .slide.active { display: block !important; }
    /* force right-carousel images to fill the slides container height for consistent sizing */
    .hero .mini-carousel.right-carousel .slide img { width: 100% !important; height: 100% !important; border-radius: 8px !important; object-fit: cover !important; display:block !important; }

    /* Small-screen adjustments so carousels fit and the right carousel is visible */
    @media (max-width: 600px) {
      .carousel-grid { gap: 8px; }
      .mini-carousel { flex: 1 1 45%; width: 45%; max-width: 45%; }
      .mini-carousel.right-carousel { order: 2; }
      .mini-carousel.middle-carousel { order: 1; }
      /* hide the leftmost (bride) carousel on mobile */
      .mini-carousel:first-of-type { display: none !important; }
      /* On small screens stack middle carousel slides vertically and show both (no animation) */
      .mini-carousel.middle-carousel .slides { display: flex; flex-direction: column; }
      .mini-carousel.middle-carousel .slide { position: static !important; opacity: 1 !important; display: block !important; }
    }
    /* default desktop visibility rules for left image (keep bride visible) */
    .desktop-only { display: block; }
    .mobile-only { display: none; }
    /* Top collage marquee (collage-style horizontal scroll) */
    .top-collage { overflow: hidden; padding: 12px 0; background: transparent; }
    .collage-track { display: flex; gap: 12px; align-items: center; will-change: transform; backface-visibility: hidden; transform: translateZ(0); }
    .collage-item { flex: 0 0 auto; border-radius: 8px; overflow: hidden; box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
    .collage-item img { display:block; width:100%; height:100%; object-fit:cover; border-radius:8px !important; }

    /* Make every image on the site render with rounded corners */
    img { border-radius: 8px !important; }

    /* Vary widths for a collage look */
    .collage-item.size-s { width: 140px; }
    .collage-item.size-m { width: 200px; }
    .collage-item.size-l { width: 260px; }

    /* scrolling animation (duplicate content needed for seamless loop) */
    /* We'll use JS-driven transform for a perfectly continuous marquee (no CSS loop jump) */
    .collage-track.scrolling { animation: none; }

    /* Responsive: smaller images and shorter animation on small screens */
    @media (max-width: 600px) {
      .collage-item.size-s { width: 110px; }
      .collage-item.size-m { width: 150px; }
      .collage-item.size-l { width: 200px; }
    }
  </style>
</head>
<body>
  <!-- Top collage marquee -->
  <section class="top-collage" aria-hidden="false">
    <div class="collage-track scrolling" id="collageTrack">
      <!-- first pass of images -->
      <figure class="collage-item size-m"><img src="hands.jpg" alt="hands"/></figure>
      
      <figure class="collage-item size-l"><img src="IMG3.jpg" alt="couple"/></figure>
      
      <figure class="collage-item size-s"><img src="wardac.jpg" alt="warda"/></figure>
      <figure class="collage-item size-m"><img src="nawal.jpg" alt="nawal"/></figure>
      <figure class="collage-item size-m"><img src="ring.jpg" alt="ring"/></figure>
      <figure class="collage-item size-s"><img src="mehndi.jpg" alt="mehndi"/></figure>
      
      <!-- duplicate sequence for seamless scroll -->
      <figure class="collage-item size-m"><img src="hands.jpg" alt="hands"/></figure>
      
      <figure class="collage-item size-l"><img src="IMG3.jpg" alt="couple"/></figure>
      
      <figure class="collage-item size-s"><img src="wardac.jpg" alt="warda"/></figure>
      <figure class="collage-item size-m"><img src="nawal.jpg" alt="nawal"/></figure>
      <figure class="collage-item size-m"><img src="ring.jpg" alt="ring"/></figure>
      <figure class="collage-item size-s"><img src="mehndi.jpg" alt="mehndi"/></figure>
      
    </div>
  </section>

  <script>
    // JS-driven continuous marquee to avoid visible jump at loop point.
    (function(){
      const track = document.getElementById('collageTrack');
      if (!track) return;

      // marquee speed in pixels per second (adjustable)
      function getMarqueeSpeed(){
        // slow the loop a little: desktop slower and mobile slightly slower
        const isMobile = (window.innerWidth || document.documentElement.clientWidth) <= 600;
        return isMobile ? 140 : 110;
      }
      let speed = getMarqueeSpeed(); // initial speed
      let offset = 0;
      let lastTime = null;
      let rafId = null;

      function updateSizes(){
        // Compute the width of a single sequence more robustly (handle gaps/rounding)
        const total = track.scrollWidth;
        const children = Array.from(track.children);
        // try to read gap between items (fallback to 12 if not set)
        const trackStyle = window.getComputedStyle(track);
        const gap = parseFloat(trackStyle.gap) || 12;

        let acc = 0;
        let seqWidth = 0;
        for (let i = 0; i < children.length; i++) {
          const el = children[i];
          const w = el.offsetWidth + gap; // include gap for pacing
          acc += w;
          // stop once we've accumulated approximately half the total width
          if (acc >= total / 2) { seqWidth = acc; break; }
        }
        track._seqWidth = seqWidth || Math.floor(total / 2) || total;
      }

      function step(ts){
        if (!lastTime) lastTime = ts;
        // cap delta to avoid large teleport jumps (e.g., when coming back from background)
        const maxDt = 0.05; // 50ms
        let dt = (ts - lastTime) / 1000;
        if (dt > maxDt) dt = maxDt;
        lastTime = ts;
        offset += speed * dt;
        if (track._seqWidth) {
          // subtract sequence width in a loop to wrap smoothly (avoids large modulo jumps)
          while (offset >= track._seqWidth) offset -= track._seqWidth;
          track.style.transform = `translate3d(${-Math.round(offset)}px,0,0)`;
        }
        rafId = requestAnimationFrame(step);
      }

      function start(){
        cancelAnimationFrame(rafId);
        updateSizes();
        // update speed on each start (handles resize and orientation change)
        speed = getMarqueeSpeed();
        lastTime = null;
        rafId = requestAnimationFrame(step);
      }

      window.addEventListener('load', start);
      window.addEventListener('resize', start);
    })();
  </script>

  <div class="page">
    <!-- INVITATION CARD -->
    <header class="invite-card">
      <div class="top-border"></div>
      <h2 class="tiny-text"></h2>
      <h1 class="names">Warda &amp; Nawal</h1>
      <p class="parents">With the blessings of their families</p>
      <p class="line">joyfully invite you to celebrate their wedding</p>

      <div class="details">
        <p class="label">Date</p>
        <p class="value">Sunday, 7 June 2026</p>
        <p class="label">Time</p>
        <p class="value">5:30 PM onwards</p>
        <p class="label">Venue</p>
        <p class="value">10227 County Road 2426, Terrell, TX 75160</p>
      </div>

      <p class="note">
        Dress code: 
        <br>Woman- Desi Festive Formal<br/>
        Men- Formal Dress
      </p>
      <div class="bottom-border"></div>
    </header>

    <!-- COUPLE PHOTOS -->
    <section class="couple-photos" aria-label="Couple photos" style="display:flex;gap:16px;justify-content:center;margin:24px 0;">
      <div style="flex:1;max-width:280px;text-align:center;">
        <img src="holding.jpg" alt="Bride" style="width:100%;height:auto;border-radius:8px;object-fit:cover;" />
      </div>
      <div style="flex:1;max-width:280px;text-align:center;">
        <img src="groom.jpg" alt="Groom" style="width:100%;height:auto;border-radius:8px;object-fit:cover;" />
      </div>
    </section>

    <!-- RSVP SECTION -->
    <section class="rsvp-section" id="rsvp">
      <h2>RSVP</h2>
      <p class="rsvp-text">
        Please let us know if you will be able to join us.
      </p>

      <form name="rsvp-to-google-sheet" class="rsvp-form">
        <label for="firstName">First Name</label>
        <input id="firstName" name="firstName" type="text" required />

        <label for="lastName">Last Name</label>
        <input id="lastName" name="lastName" type="text" required />

        <!-- Hidden concatenated full name for backend compatibility -->
        <input id="name" name="name" type="hidden" />

        <label for="side">Are you from the groom's side or the bride's side?</label>
        <select id="side" name="side" required>
          <option value="">Select...</option>
          <option value="groom">Groom's side</option>
          <option value="bride">Bride's side</option>
        </select>

        <label for="attendance">Will you attend?</label>
        <select id="attendance" name="attendance" required>
          <option value="">Select an option</option>
          <option value="yes">Yes, I will be there</option>
          <option value="no">Sorry, I cannot attend</option>
        </select>

        <div id="attendingFields">
          <label for="guests">Number of Guests (excluding you)</label>
          <input
            id="guests"
            name="guests"
            type="number"
            min="0"
            max="10"
            value="0"
          />

          <div id="guestList" aria-live="polite"></div>

          <label for="meal">Your Meal Preference</label>
          <select id="meal" name="meal">
            <option value="">Select...</option>
            <option value="veg">Veg</option>
            <option value="non-veg">Non‑veg</option>
            <option value="na">N/A</option>
          </select>
        </div>

        <label for="message">Message for the couple</label>
        <textarea id="message" name="message" rows="3"></textarea>

        <button type="submit">Submit RSVP</button>
        <p class="success-message" id="successMessage" hidden>
          Shukriya! Your RSVP has been received.
        </p>
        <p class="error-message" id="errorMessage" hidden>
          Something went wrong. Please try again.
        </p>
      </form>
    </section>
  </div>

  <script>
    // ------------ CAROUSEL (multiple mini carousels) ------------
    document.querySelectorAll('.mini-carousel').forEach((carousel) => {
      const slides = carousel.querySelectorAll('.slide');
      const prevBtn = carousel.querySelector('.carousel-btn.prev');
      const nextBtn = carousel.querySelector('.carousel-btn.next');
      let current = 0;

      function show(i) {
        slides.forEach((s, idx) => s.classList.toggle('active', idx === i));
      }

      function goNext() {
        current = (current + 1) % slides.length;
        show(current);
      }

      function goPrev() {
        current = (current - 1 + slides.length) % slides.length;
        show(current);
      }

      if (nextBtn) nextBtn.addEventListener('click', goNext);
      if (prevBtn) prevBtn.addEventListener('click', goPrev);

        if (slides.length > 1) {
          // Auto-advance only for the right-most carousel; other carousels (middle/static) remain still images
          if (carousel.classList.contains('right-carousel')) {
            setInterval(goNext, 4000 + Math.floor(Math.random() * 2000));
          }
        }
    });

    // Sync all mini-carousel heights to the tallest rendered slide image so visuals match
    function syncCarouselHeights() {
      const carousels = Array.from(document.querySelectorAll('.mini-carousel'));
      if (carousels.length === 0) return;

      // Find the tallest rendered image height among the first slide img of each carousel
      let maxH = 0;
      carousels.forEach((c) => {
          // Skip middle carousel on small screens so it can stack its slides vertically
          if ((window.innerWidth || document.documentElement.clientWidth) <= 600 && c.classList.contains('middle-carousel')) return;
        const img = c.querySelector('.slide img');
        if (img) {
          // offsetHeight is the rendered height
          const h = img.offsetHeight || img.clientHeight || 0;
          if (h > maxH) maxH = h;
        }
      });

      // If no images measured yet, try again shortly (images may still be loading)
      if (maxH === 0) {
        setTimeout(syncCarouselHeights, 150);
        return;
      }

      // Apply the max height to every carousel's slides container (except middle on mobile)
      carousels.forEach((c) => {
        const slides = c.querySelector('.slides');
        if (!slides) return;
        if ((window.innerWidth || document.documentElement.clientWidth) <= 600 && c.classList.contains('middle-carousel')) {
          slides.style.height = 'auto';
        } else {
          slides.style.height = `${maxH}px`;
        }
      });
    }

    window.addEventListener('load', () => { syncCarouselHeights(); setTimeout(syncCarouselHeights, 300); });
    window.addEventListener('resize', () => { setTimeout(syncCarouselHeights, 120); });

    // Ensure the middle carousel uses IMG3's rendered height on larger screens so hands matches IMG3
    function fixMiddleCarouselHeight() {
      if ((window.innerWidth || document.documentElement.clientWidth) <= 600) return; // don't force height on small screens
      const middle = document.querySelector('.mini-carousel.middle-carousel');
      if (!middle) return;
      const img = middle.querySelector('.slides .slide.active img') || middle.querySelector('.slides img');
      const slides = middle.querySelector('.slides');
      if (!img || !slides) return;
      const h = img.offsetHeight || img.clientHeight || 0;
      if (h > 0) slides.style.height = `${h}px`;
      else setTimeout(fixMiddleCarouselHeight, 150);
    }

    window.addEventListener('load', () => { fixMiddleCarouselHeight(); setTimeout(fixMiddleCarouselHeight, 350); });
    window.addEventListener('resize', () => { setTimeout(fixMiddleCarouselHeight, 150); });

    // On desktop, size IMG3+hands so their combined height matches the right carousel
    function matchMiddleToRightHeight() {
      const isDesktop = (window.innerWidth || document.documentElement.clientWidth) > 600;
      if (!isDesktop) {
        // reset any inline heights on smaller screens
        const middleSlides = document.querySelector('.mini-carousel.middle-carousel .slides');
        if (middleSlides) { middleSlides.style.height = ''; const imgs = middleSlides.querySelectorAll('img'); imgs.forEach(i => i.style.height = ''); }
        return;
      }

      const rightSlides = document.querySelector('.mini-carousel.right-carousel .slides');
      const middleSlides = document.querySelector('.mini-carousel.middle-carousel .slides');
      if (!rightSlides || !middleSlides) return;

      const rightH = rightSlides.offsetHeight || rightSlides.clientHeight || 0;
      if (!rightH) return setTimeout(matchMiddleToRightHeight, 120);

      // set middle container to match right's height and split evenly between stacked images
      middleSlides.style.height = `${rightH}px`;
      const middleImgs = Array.from(middleSlides.querySelectorAll('.slide'));
      const eachH = Math.floor(rightH / Math.max(1, middleImgs.length));
      middleImgs.forEach((s) => {
        s.style.height = `${eachH}px`;
        const img = s.querySelector('img');
        if (img) img.style.height = `${eachH}px`;
      });
    }

    window.addEventListener('load', () => { matchMiddleToRightHeight(); setTimeout(matchMiddleToRightHeight, 400); });
    window.addEventListener('resize', () => { setTimeout(matchMiddleToRightHeight, 180); });

    // ------------ RSVP + GOOGLE SHEETS ------------
    // Vercel function URL (deployed)
    const scriptURL = 'https://wardas-rsvp.vercel.app/api/rsvp';
    const form = document.forms['rsvp-to-google-sheet'];
    const successMessage = document.getElementById('successMessage');
    const errorMessage = document.getElementById('errorMessage');
    const attendanceSelect = document.getElementById('attendance');
    const attendingFields = document.getElementById('attendingFields');
    const guestsInput = document.getElementById('guests');
    const guestList = document.getElementById('guestList');
    const mealSelect = document.getElementById('meal');
    const firstNameInput = document.getElementById('firstName');
    const lastNameInput = document.getElementById('lastName');
    const fullNameHidden = document.getElementById('name');

    function updateAttendingFields() {
      const attending = attendanceSelect.value === 'yes';
      attendingFields.style.display = attending ? 'block' : 'none';

      if (!attending) {
        guestsInput.value = 0;
        renderGuestFields(0);
      }
    }

    function renderGuestFields(count) {
      guestList.innerHTML = '';
      count = Math.max(0, Math.min(10, parseInt(count || 0, 10)));

      for (let i = 1; i <= count; i++) {
        const wrapper = document.createElement('div');
        wrapper.className = 'guest-card';

        wrapper.innerHTML = `
          <h4>Guest ${i}</h4>
          <label for="guest_${i}_first">First Name</label>
          <input id="guest_${i}_first" name="guest_${i}_first" type="text" required />

          <label for="guest_${i}_last">Last Name</label>
          <input id="guest_${i}_last" name="guest_${i}_last" type="text" required />

          <!-- Hidden concatenated full name for backend compatibility -->
          <input id="guest_${i}_name" name="guest_${i}_name" type="hidden" />

          <div class="guest-meal-display"><span id="guest_${i}_meal_display"></span></div>
          <label for="guest_${i}_meal">Meal Preference</label>
          <select id="guest_${i}_meal" name="guest_${i}_meal">
            <option value="">Select...</option>
            <option value="veg">Veg</option>
            <option value="non-veg">Non‑veg</option>
            <option value="na">N/A</option>
          </select>
        `;

        guestList.appendChild(wrapper);

        const mealSel = wrapper.querySelector(`#guest_${i}_meal`);
        const mealDisp = wrapper.querySelector(`#guest_${i}_meal_display`);
        mealSel.addEventListener('change', () => {
          mealDisp.textContent = mealSel.value || '';
        });
      }
    }

    function enforceGuestNamesRequirement() {
      const guests = parseInt(guestsInput.value || '0', 10);
      for (let i = 1; i <= 10; i++) {
        const firstInput = document.getElementById(`guest_${i}_first`);
        const lastInput = document.getElementById(`guest_${i}_last`);
        if (firstInput) {
          if (i <= guests) firstInput.setAttribute('required', 'required');
          else {
            firstInput.removeAttribute('required');
            firstInput.value = '';
          }
        }
        if (lastInput) {
          if (i <= guests) lastInput.setAttribute('required', 'required');
          else {
            lastInput.removeAttribute('required');
            lastInput.value = '';
          }
        }
        // clear hidden concatenated name for non-existing guests
        const hidden = document.getElementById(`guest_${i}_name`);
        if (hidden && i > guests) hidden.value = '';
      }
    }

    attendanceSelect.addEventListener('change', updateAttendingFields);
    guestsInput.addEventListener('input', () => {
      renderGuestFields(guestsInput.value);
      enforceGuestNamesRequirement();
    });

    updateAttendingFields();
    renderGuestFields(guestsInput.value);
    enforceGuestNamesRequirement();

    form.addEventListener('submit', (e) => {
      e.preventDefault();
      successMessage.hidden = true;
      errorMessage.hidden = true;
      errorMessage.textContent = 'Something went wrong. Please try again.';

      // Populate hidden full name for server-side compatibility
      if (firstNameInput && lastNameInput && fullNameHidden) {
        const f = (firstNameInput.value || '').trim();
        const l = (lastNameInput.value || '').trim();
        fullNameHidden.value = (f || l) ? `${f} ${l}`.trim() : '';
      }

      const guests = parseInt(guestsInput.value || '0', 10);
      if (attendanceSelect.value === 'yes') {
        for (let i = 1; i <= guests; i++) {
          const first = document.getElementById(`guest_${i}_first`);
          const last = document.getElementById(`guest_${i}_last`);
          const hidden = document.getElementById(`guest_${i}_name`);
          const firstVal = first ? (first.value || '').trim() : '';
          const lastVal = last ? (last.value || '').trim() : '';

          if (!firstVal || !lastVal) {
            errorMessage.textContent = `Please enter first and last name for Guest ${i}.`;
            errorMessage.hidden = false;
            return;
          }

          // populate hidden concatenated name for backend
          if (hidden) hidden.value = `${firstVal} ${lastVal}`.trim();
        }
      }

      // Send URL-encoded payload and handle errors with detailed logging
      const payload = new URLSearchParams(new FormData(form));
      fetch(scriptURL, {
        method: 'POST',
        body: payload,
      })
        .then(async (res) => {
          if (!res.ok) {
            const text = await res.text().catch(() => '');
            throw new Error(`HTTP ${res.status} ${res.statusText} - ${text}`);
          }
          try {
            return await res.json();
          } catch (e) {
            return { status: 'ok' };
          }
        })
        .then((data) => {
          successMessage.hidden = false;
          form.reset();
          updateAttendingFields();
          renderGuestFields(0);
          enforceGuestNamesRequirement();
          // ensure hidden name cleared after reset
          if (fullNameHidden) fullNameHidden.value = '';
          // clear guest hidden names as well
          for (let i = 1; i <= 10; i++) {
            const h = document.getElementById(`guest_${i}_name`);
            if (h) h.value = '';
          }
        })
        .catch((err) => {
          console.error('Submit error:', err);
          errorMessage.textContent = err.message || 'Something went wrong. Please try again.';
          errorMessage.hidden = false;
        });
    });
  </script>
</body>
</html>
